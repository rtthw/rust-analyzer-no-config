//! Config used by the language server.
//!
//! Of particular interest is the `feature_flags` hash map: while other fields
//! configure the server itself, feature flags are passed into analysis, and
//! tweak things like automatic insertion of `()` in completions.
use std::fmt;

use cfg::{CfgAtom, CfgDiff};
use hir::Symbol;
use ide::{
    AnnotationConfig, AssistConfig, CallHierarchyConfig, CallableSnippets, CompletionConfig,
    CompletionFieldsToResolve, DiagnosticsConfig, GenericParameterHints, GotoDefinitionConfig,
    GotoImplementationConfig, HighlightConfig, HighlightRelatedConfig, HoverConfig, HoverDocFormat,
    InlayFieldsToResolve, InlayHintsConfig, JoinLinesConfig, MemoryLayoutHoverConfig,
    MemoryLayoutHoverRenderKind, RenameConfig, Snippet, SourceRootId,
};
use ide_db::{
    MiniCore, SnippetCap,
    assists::ExprFillDefaultMode,
    imports::insert_use::{ImportGranularity, InsertUseConfig, PrefixKind},
};
use itertools::{Either, Itertools};
use paths::{Utf8Path, Utf8PathBuf};
use project_model::{
    CargoConfig, CargoFeatures, ProjectJson, ProjectJsonData, ProjectJsonFromCommand,
    ProjectManifest, RustLibSource,
};
use rustc_hash::{FxHashMap, FxHashSet};
use semver::Version;
use serde::{Deserialize, Serialize};
use vfs::{AbsPath, AbsPathBuf};

use crate::{
    diagnostics::DiagnosticsMapConfig,
    flycheck::{CargoOptions, FlycheckConfig},
    lsp::capabilities::ClientCapabilities,
    lsp_ext::{WorkspaceSymbolSearchKind, WorkspaceSymbolSearchScope},
};

// Conventions for configuration keys to preserve maximal extendability without breakage:
//  - Toggles (be it binary true/false or with more options in-between) should almost always suffix as `_enable`
//    This has the benefit of namespaces being extensible, and if the suffix doesn't fit later it can be changed without breakage.
//  - In general be wary of using the namespace of something verbatim, it prevents us from adding subkeys in the future
//  - Don't use abbreviations unless really necessary
//  - foo_command = overrides the subcommand, foo_overrideCommand allows full overwriting, extra args only applies for foo_command

#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub enum MaxSubstitutionLength {
    Hide,
    #[serde(untagged)]
    Limit(usize),
}

#[derive(Clone, Debug)]
struct ClientInfo {
    name: String,
    version: Option<Version>,
}

#[derive(Clone)]
pub struct Config {
    /// Projects that have a Cargo.toml or a rust-project.json in a
    /// parent directory, so we can discover them by walking the
    /// file system.
    discovered_projects_from_filesystem: Vec<ProjectManifest>,
    /// Projects whose configuration was generated by a command
    /// configured in discoverConfig.
    discovered_projects_from_command: Vec<ProjectJsonFromCommand>,
    /// The workspace roots as registered by the LSP client
    workspace_roots: Vec<AbsPathBuf>,
    caps: ClientCapabilities,
    root_path: AbsPathBuf,
    snippets: Vec<Snippet>,
    client_info: Option<ClientInfo>,
}

impl fmt::Debug for Config {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("Config")
            .field("discovered_projects_from_filesystem", &self.discovered_projects_from_filesystem)
            .field("discovered_projects_from_command", &self.discovered_projects_from_command)
            .field("workspace_roots", &self.workspace_roots)
            .field("caps", &self.caps)
            .field("root_path", &self.root_path)
            .field("snippets", &self.snippets)
            .field("client_info", &self.client_info)
            .finish()
    }
}

// Delegate capability fetching methods
impl std::ops::Deref for Config {
    type Target = ClientCapabilities;

    fn deref(&self) -> &Self::Target {
        &self.caps
    }
}

impl Config {
    pub fn add_discovered_project_from_command(
        &mut self,
        data: ProjectJsonData,
        buildfile: AbsPathBuf,
    ) {
        for proj in self.discovered_projects_from_command.iter_mut() {
            if proj.buildfile == buildfile {
                proj.data = data;
                return;
            }
        }

        self.discovered_projects_from_command.push(ProjectJsonFromCommand { data, buildfile });
    }
}

#[derive(Debug, Clone, Eq, PartialEq)]
pub enum LinkedProject {
    ProjectManifest(ProjectManifest),
    InlineProjectJson(ProjectJson),
}

impl From<ProjectManifest> for LinkedProject {
    fn from(v: ProjectManifest) -> Self {
        LinkedProject::ProjectManifest(v)
    }
}

impl From<ProjectJson> for LinkedProject {
    fn from(v: ProjectJson) -> Self {
        LinkedProject::InlineProjectJson(v)
    }
}

#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct DiscoverWorkspaceConfig {
    pub command: Vec<String>,
    pub progress_label: String,
    pub files_to_watch: Vec<String>,
}

pub struct CallInfoConfig {
    pub params_only: bool,
    pub docs: bool,
}

#[derive(Clone, Debug, PartialEq, Eq)]
pub struct LensConfig {
    // runnables
    pub run: bool,
    pub debug: bool,
    pub update_test: bool,
    pub interpret: bool,

    // implementations
    pub implementations: bool,

    // references
    pub method_refs: bool,
    pub refs_adt: bool,   // for Struct, Enum, Union and Trait
    pub refs_trait: bool, // for Struct, Enum, Union and Trait
    pub enum_variant_refs: bool,

    // annotations
    pub location: AnnotationLocation,
    pub filter_adjacent_derive_implementations: bool,
}

#[derive(Copy, Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum AnnotationLocation {
    AboveName,
    AboveWholeItem,
}

impl From<AnnotationLocation> for ide::AnnotationLocation {
    fn from(location: AnnotationLocation) -> Self {
        match location {
            AnnotationLocation::AboveName => ide::AnnotationLocation::AboveName,
            AnnotationLocation::AboveWholeItem => ide::AnnotationLocation::AboveWholeItem,
        }
    }
}

impl LensConfig {
    pub fn any(&self) -> bool {
        self.run
            || self.debug
            || self.update_test
            || self.implementations
            || self.method_refs
            || self.refs_adt
            || self.refs_trait
            || self.enum_variant_refs
    }

    pub fn none(&self) -> bool {
        !self.any()
    }

    pub fn runnable(&self) -> bool {
        self.run || self.debug || self.update_test
    }

    pub fn references(&self) -> bool {
        self.method_refs || self.refs_adt || self.refs_trait || self.enum_variant_refs
    }

    pub fn into_annotation_config<'a>(
        self,
        binary_target: bool,
        minicore: MiniCore<'a>,
    ) -> AnnotationConfig<'a> {
        AnnotationConfig {
            binary_target,
            annotate_runnables: self.runnable(),
            annotate_impls: self.implementations,
            annotate_references: self.refs_adt,
            annotate_method_references: self.method_refs,
            annotate_enum_variant_references: self.enum_variant_refs,
            location: self.location.into(),
            minicore,
            filter_adjacent_derive_implementations: self.filter_adjacent_derive_implementations,
        }
    }
}

#[derive(Clone, Debug, PartialEq, Eq)]
pub struct HoverActionsConfig {
    pub implementations: bool,
    pub references: bool,
    pub run: bool,
    pub debug: bool,
    pub update_test: bool,
    pub goto_type_def: bool,
}

impl HoverActionsConfig {
    pub const NO_ACTIONS: Self = Self {
        implementations: false,
        references: false,
        run: false,
        debug: false,
        update_test: false,
        goto_type_def: false,
    };

    pub fn any(&self) -> bool {
        self.implementations || self.references || self.runnable() || self.goto_type_def
    }

    pub fn none(&self) -> bool {
        !self.any()
    }

    pub fn runnable(&self) -> bool {
        self.run || self.debug || self.update_test
    }
}

#[derive(Debug, Clone)]
pub struct FilesConfig {
    pub watcher: FilesWatcher,
}

#[derive(Debug, Clone)]
pub enum FilesWatcher {
    Client,
    Server,
}

/// Configuration for document symbol search requests.
#[derive(Debug, Clone)]
pub struct DocumentSymbolConfig {
    /// Should locals be excluded.
    pub search_exclude_locals: bool,
}

#[derive(Debug, Clone)]
pub struct NotificationsConfig {
    pub cargo_toml_not_found: bool,
}

#[derive(Debug, Clone)]
pub enum RustfmtConfig {
    Rustfmt { enable_range_formatting: bool },
    CustomCommand { command: String, args: Vec<String> },
}

/// Configuration for runnable items, such as `main` function or tests.
#[derive(Debug, Clone)]
pub struct RunnablesConfig {
    /// Custom command to be executed instead of `cargo` for runnables.
    pub override_cargo: Option<String>,
    /// Additional arguments for the binary being run, if it is a test or benchmark.
    pub extra_test_binary_args: Vec<String>,
}

/// Configuration for workspace symbol search requests.
#[derive(Debug, Clone)]
pub struct WorkspaceSymbolConfig {
    /// Should imports be excluded.
    pub search_exclude_imports: bool,
    /// In what scope should the symbol be searched in.
    pub search_scope: WorkspaceSymbolSearchScope,
    /// What kind of symbol is being searched for.
    pub search_kind: WorkspaceSymbolSearchKind,
    /// How many items are returned at most.
    pub search_limit: usize,
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct ClientCommandsConfig {
    pub run_single: bool,
    pub debug_single: bool,
    pub show_reference: bool,
    pub goto_location: bool,
    pub trigger_parameter_hints: bool,
    pub rename: bool,
}

impl Config {
    pub fn new(
        root_path: AbsPathBuf,
        caps: lsp_types::ClientCapabilities,
        workspace_roots: Vec<AbsPathBuf>,
        client_info: Option<lsp_types::ClientInfo>,
    ) -> Self {
        let mut this = Config {
            caps: ClientCapabilities::new(caps),
            discovered_projects_from_filesystem: Vec::new(),
            discovered_projects_from_command: Vec::new(),
            root_path,
            snippets: Default::default(),
            workspace_roots,
            client_info: client_info.map(|it| ClientInfo {
                name: it.name,
                version: it.version.as_deref().map(Version::parse).and_then(Result::ok),
            }),
        };
        this.rediscover_workspaces();
        this
    }

    pub fn rediscover_workspaces(&mut self) {
        let discovered = ProjectManifest::discover_all(&self.workspace_roots);
        tracing::info!("discovered projects: {:?}", discovered);
        if discovered.is_empty() {
            tracing::error!("failed to find any projects in {:?}", &self.workspace_roots);
        }
        self.discovered_projects_from_filesystem = discovered;
    }

    pub fn remove_workspace(&mut self, path: &AbsPath) {
        if let Some(position) = self.workspace_roots.iter().position(|it| it == path) {
            self.workspace_roots.remove(position);
        }
    }

    pub fn add_workspaces(&mut self, paths: impl Iterator<Item = AbsPathBuf>) {
        self.workspace_roots.extend(paths);
    }

    pub fn root_path(&self) -> &AbsPathBuf {
        &self.root_path
    }

    pub fn caps(&self) -> &ClientCapabilities {
        &self.caps
    }
}

impl Config {
    pub fn assist(&self) -> AssistConfig {
        AssistConfig {
            snippet_cap: self.snippet_cap(),
            allowed: None,
            insert_use: self.insert_use_config(),
            prefer_no_std: false,
            assist_emit_must_use: false,
            prefer_prelude: false,
            prefer_absolute: false,
            term_search_fuel: 1800,
            term_search_borrowck: true,
            code_action_grouping: self.code_action_group(),
            expr_fill_default: ExprFillDefaultMode::Todo,
            prefer_self_ty: false,
        }
    }

    pub fn rename(&self) -> RenameConfig {
        RenameConfig { prefer_no_std: false, prefer_prelude: false, prefer_absolute: false }
    }

    pub fn call_hierarchy<'a>(&self, minicore: MiniCore<'a>) -> CallHierarchyConfig<'a> {
        CallHierarchyConfig { exclude_tests: false, minicore }
    }

    pub fn completion<'a>(&'a self, minicore: MiniCore<'a>) -> CompletionConfig<'a> {
        let client_capability_fields = self.completion_resolve_support_properties();
        CompletionConfig {
            enable_postfix_completions: true,
            enable_imports_on_the_fly: self.caps.has_completion_item_resolve_additionalTextEdits(),
            enable_self_on_the_fly: true,
            enable_auto_iter: true,
            enable_auto_await: true,
            enable_private_editable: false,
            full_function_signatures: false,
            callable: Some(CallableSnippets::FillArguments),
            add_semicolon_to_unit: true,
            snippet_cap: SnippetCap::new(self.completion_snippet()),
            insert_use: self.insert_use_config(),
            prefer_no_std: false,
            prefer_prelude: false,
            prefer_absolute: false,
            snippets: self.snippets.clone().to_vec(),
            limit: None,
            enable_term_search: false,
            term_search_fuel: 1000,
            fields_to_resolve: if self.client_is_neovim() {
                CompletionFieldsToResolve::empty()
            } else {
                CompletionFieldsToResolve::from_client_capabilities(&client_capability_fields)
            },
            exclude_flyimport: vec![
                AutoImportExclusion::Verbose {
                    path: "core::borrow::Borrow".to_owned(),
                    r#type: AutoImportExclusionType::Methods,
                },
                AutoImportExclusion::Verbose {
                    path: "core::borrow::BorrowMut".to_owned(),
                    r#type: AutoImportExclusionType::Methods,
                },
            ]
            .iter()
            .map(|it| match it {
                AutoImportExclusion::Path(path) => {
                    (path.clone(), ide_completion::AutoImportExclusionType::Always)
                }
                AutoImportExclusion::Verbose { path, r#type } => (
                    path.clone(),
                    match r#type {
                        AutoImportExclusionType::Always => {
                            ide_completion::AutoImportExclusionType::Always
                        }
                        AutoImportExclusionType::Methods => {
                            ide_completion::AutoImportExclusionType::Methods
                        }
                    },
                ),
            })
            .collect(),
            exclude_traits: &[],
            minicore,
        }
    }

    pub fn diagnostics(&self) -> DiagnosticsConfig {
        DiagnosticsConfig {
            enabled: true,
            proc_attr_macros_enabled: true,
            proc_macros_enabled: true,
            disable_experimental: true,
            disabled: FxHashSet::default(),
            expr_fill_default: ExprFillDefaultMode::Todo,
            snippet_cap: self.snippet_cap(),
            insert_use: self.insert_use_config(),
            prefer_no_std: false,
            prefer_prelude: false,
            prefer_absolute: false,
            style_lints: false,
            term_search_fuel: 1800,
            term_search_borrowck: true,
        }
    }

    pub fn diagnostic_fixes(&self) -> DiagnosticsConfig {
        // We always want to show quickfixes for diagnostics, even when diagnostics/experimental diagnostics are disabled.
        DiagnosticsConfig { enabled: true, disable_experimental: false, ..self.diagnostics() }
    }

    pub fn highlight_related(&self, _source_root: Option<SourceRootId>) -> HighlightRelatedConfig {
        HighlightRelatedConfig {
            references: true,
            break_points: true,
            exit_points: true,
            yield_points: true,
            closure_captures: true,
            branch_exit_points: true,
        }
    }

    pub fn hover_actions(&self) -> HoverActionsConfig {
        let enable = self.caps.hover_actions();
        HoverActionsConfig {
            implementations: enable && true,
            references: false,
            run: enable && true,
            debug: enable,
            update_test: enable,
            goto_type_def: enable,
        }
    }

    pub fn hover<'a>(&self, minicore: MiniCore<'a>) -> HoverConfig<'a> {
        HoverConfig {
            links_in_hover: true,
            memory_layout: Some(MemoryLayoutHoverConfig {
                size: Some(MemoryLayoutHoverRenderKind::Both),
                offset: Some(MemoryLayoutHoverRenderKind::Hexadecimal),
                alignment: Some(MemoryLayoutHoverRenderKind::Hexadecimal),
                padding: None,
                niches: false,
            }),
            documentation: true,
            format: {
                if self.caps.hover_markdown_support() {
                    HoverDocFormat::Markdown
                } else {
                    HoverDocFormat::PlainText
                }
            },
            keywords: true,
            max_trait_assoc_items_count: None,
            max_fields_count: Some(5),
            max_enum_variants_count: Some(5),
            max_subst_ty_len: ide::SubstTyLen::LimitTo(20),
            show_drop_glue: true,
            minicore,
        }
    }

    pub fn goto_definition<'a>(&self, minicore: MiniCore<'a>) -> GotoDefinitionConfig<'a> {
        GotoDefinitionConfig { minicore }
    }

    pub fn inlay_hints<'a>(&self, minicore: MiniCore<'a>) -> InlayHintsConfig<'a> {
        let client_capability_fields = self.inlay_hint_resolve_support_properties();

        InlayHintsConfig {
            render_colons: true,
            type_hints: true,
            sized_bound: false,
            parameter_hints: true,
            generic_parameter_hints: GenericParameterHints {
                type_hints: false,
                lifetime_hints: false,
                const_hints: true,
            },
            chaining_hints: true,
            discriminant_hints: ide::DiscriminantHints::Never,
            closure_return_type_hints: ide::ClosureReturnTypeHints::Never,
            lifetime_elision_hints: ide::LifetimeElisionHints::Never,
            hide_named_constructor_hints: false,
            hide_closure_initialization_hints: false,
            hide_closure_parameter_hints: false,
            closure_style: hir::ClosureStyle::ImplFn,
            closure_capture_hints: false,
            adjustment_hints: ide::AdjustmentHints::Never,
            adjustment_hints_disable_reborrows: true,
            adjustment_hints_mode: ide::AdjustmentHintsMode::Prefix,
            adjustment_hints_hide_outside_unsafe: false,
            binding_mode_hints: false,
            param_names_for_lifetime_elision_hints: false,
            max_length: Some(25),
            closing_brace_hints_min_lines: Some(25),
            fields_to_resolve: InlayFieldsToResolve::from_client_capabilities(
                &client_capability_fields,
            ),
            implicit_drop_hints: false,
            range_exclusive_hints: false,
            minicore,
        }
    }

    fn insert_use_config(&self) -> InsertUseConfig {
        InsertUseConfig {
            granularity: ImportGranularity::Crate,
            enforce_granularity: false,
            prefix_kind: PrefixKind::ByCrate,
            group: true,
            skip_glob_imports: false,
        }
    }

    pub fn join_lines(&self) -> JoinLinesConfig {
        JoinLinesConfig {
            join_else_if: true,
            remove_trailing_comma: true,
            unwrap_trivial_blocks: true,
            join_assignments: true,
        }
    }

    pub fn highlighting_config<'a>(&self, minicore: MiniCore<'a>) -> HighlightConfig<'a> {
        HighlightConfig {
            strings: true,
            comments: true,
            punctuation: false,
            specialize_punctuation: false,
            macro_bang: false,
            operator: true,
            specialize_operator: false,
            inject_doc_comment: true,
            syntactic_name_ref_highlighting: false,
            minicore,
        }
    }

    pub fn discover_workspace_config(&self) -> Option<&DiscoverWorkspaceConfig> {
        None
    }

    fn discovered_projects(&self) -> Vec<ManifestOrProjectJson> {
        let mut projects = vec![];
        for fs_proj in &self.discovered_projects_from_filesystem {
            let manifest_path = fs_proj.manifest_path();

            let buf: Utf8PathBuf = manifest_path.to_path_buf().into();
            projects.push(ManifestOrProjectJson::Manifest(buf));
        }

        for dis_proj in &self.discovered_projects_from_command {
            projects.push(ManifestOrProjectJson::DiscoveredProjectJson {
                data: dis_proj.data.clone(),
                buildfile: dis_proj.buildfile.clone(),
            });
        }

        projects
    }

    pub fn linked_or_discovered_projects(&self) -> Vec<LinkedProject> {
        self.discovered_projects()
            .iter()
            .filter_map(|linked_project| match linked_project {
                ManifestOrProjectJson::Manifest(it) => {
                    let path = self.root_path.join(it);
                    ProjectManifest::from_manifest_file(path)
                        .map_err(|e| tracing::error!("failed to load linked project: {}", e))
                        .ok()
                        .map(Into::into)
                }
                ManifestOrProjectJson::DiscoveredProjectJson { data, buildfile } => {
                    let root_path = buildfile.parent().expect("Unable to get parent of buildfile");

                    Some(ProjectJson::new(None, root_path, data.clone()).into())
                }
                ManifestOrProjectJson::ProjectJson(it) => {
                    Some(ProjectJson::new(None, &self.root_path, it.clone()).into())
                }
            })
            .collect()
    }

    pub fn diagnostics_map(&self) -> DiagnosticsMapConfig {
        DiagnosticsMapConfig {
            remap_prefix: FxHashMap::default(),
            warnings_as_info: Vec::new(),
            warnings_as_hint: Vec::new(),
            check_ignore: FxHashSet::default(),
        }
    }

    pub fn files(&self) -> FilesConfig {
        FilesConfig {
            watcher: if self.did_change_watched_files_dynamic_registration() {
                FilesWatcher::Client
            } else {
                FilesWatcher::Server
            },
        }
    }

    pub fn notifications(&self) -> NotificationsConfig {
        NotificationsConfig { cargo_toml_not_found: true }
    }

    pub fn cargo(&self) -> CargoConfig {
        let rustc_source = None;
        let sysroot = Some(RustLibSource::Discover);
        let sysroot_src = None;
        let extra_includes = Vec::new();

        CargoConfig {
            all_targets: true,
            features: CargoFeatures::Selected { features: vec![], no_default_features: false },
            target: None,
            sysroot,
            sysroot_src,
            rustc_source,
            extra_includes,
            cfg_overrides: project_model::CfgOverrides {
                global: {
                    let (enabled, disabled): (Vec<_>, Vec<_>) =
                        ["debug_assertions", "miri"].iter().partition_map(|s| {
                            s.strip_prefix("!").map_or(Either::Left(s), Either::Right)
                        });
                    CfgDiff::new(
                        enabled
                            .into_iter()
                            // parse any cfg setting formatted as key=value or just key (without value)
                            .map(|s: &str| match s.split_once("=") {
                                Some((key, val)) => CfgAtom::KeyValue {
                                    key: Symbol::intern(key),
                                    value: Symbol::intern(val),
                                },
                                None => CfgAtom::Flag(Symbol::intern(s)),
                            })
                            .collect(),
                        disabled
                            .into_iter()
                            .map(|s| match s.split_once("=") {
                                Some((key, val)) => CfgAtom::KeyValue {
                                    key: Symbol::intern(key),
                                    value: Symbol::intern(val),
                                },
                                None => CfgAtom::Flag(Symbol::intern(s)),
                            })
                            .collect(),
                    )
                },
                selective: Default::default(),
            },
            wrap_rustc_in_build_scripts: true,
            invocation_strategy: project_model::InvocationStrategy::PerWorkspace,
            run_build_script_command: None,
            target_dir: None,
            set_test: true,
            no_deps: false,
        }
    }

    pub fn rustfmt(&self) -> RustfmtConfig {
        RustfmtConfig::Rustfmt { enable_range_formatting: false }
    }

    pub(crate) fn cargo_test_options(&self) -> CargoOptions {
        CargoOptions {
            target_tuples: vec![],
            all_targets: false,
            no_default_features: false,
            all_features: false,
            features: Vec::new(),
            extra_test_bin_args: vec!["--nocapture".to_owned()],
            target_dir: None,
            set_test: true,
        }
    }

    pub(crate) fn flycheck(&self) -> FlycheckConfig {
        FlycheckConfig::CargoCommand {
            command: "check".to_string(),
            options: CargoOptions {
                target_tuples: Vec::new(),
                all_targets: true,
                no_default_features: false,
                all_features: false,
                features: Vec::new(),
                extra_test_bin_args: vec!["--nocapture".to_owned()],
                target_dir: None,
                set_test: true,
            },
            ansi_color_output: self.color_diagnostic_output(),
        }
    }

    pub fn runnables(&self) -> RunnablesConfig {
        RunnablesConfig {
            override_cargo: None,
            extra_test_binary_args: vec!["--nocapture".to_owned()],
        }
    }

    pub fn snippet_cap(&self) -> Option<SnippetCap> {
        // FIXME: Also detect the proposed lsp version at caps.workspace.workspaceEdit.snippetEditSupport
        // once lsp-types has it.
        SnippetCap::new(self.snippet_text_edit())
    }

    pub fn call_info(&self) -> CallInfoConfig {
        CallInfoConfig { params_only: false, docs: true }
    }

    pub fn lens(&self) -> LensConfig {
        LensConfig {
            run: true,
            debug: true,
            update_test: true,
            interpret: false,
            implementations: true,
            method_refs: false,
            refs_adt: false,
            refs_trait: false,
            enum_variant_refs: false,
            location: AnnotationLocation::AboveName,
            filter_adjacent_derive_implementations: false,
        }
    }

    pub fn goto_implementation(&self) -> GotoImplementationConfig {
        GotoImplementationConfig { filter_adjacent_derive_implementations: false }
    }

    pub fn document_symbol(&self) -> DocumentSymbolConfig {
        DocumentSymbolConfig { search_exclude_locals: true }
    }

    pub fn workspace_symbol(&self) -> WorkspaceSymbolConfig {
        WorkspaceSymbolConfig {
            search_exclude_imports: false,
            search_scope: WorkspaceSymbolSearchScope::Workspace,
            search_kind: WorkspaceSymbolSearchKind::OnlyTypes,
            search_limit: 128,
        }
    }

    pub fn client_commands(&self) -> ClientCommandsConfig {
        let commands = self.commands().map(|it| it.commands).unwrap_or_default();

        let get = |name: &str| commands.iter().any(|it| it == name);

        ClientCommandsConfig {
            run_single: get("rust-analyzer.runSingle"),
            debug_single: get("rust-analyzer.debugSingle"),
            show_reference: get("rust-analyzer.showReferences"),
            goto_location: get("rust-analyzer.gotoLocation"),
            trigger_parameter_hints: get("rust-analyzer.triggerParameterHints"),
            rename: get("rust-analyzer.rename"),
        }
    }

    pub fn prime_caches_num_threads(&self) -> usize {
        num_cpus::get_physical()
    }

    pub fn main_loop_num_threads(&self) -> usize {
        num_cpus::get_physical()
    }

    pub fn typing_trigger_chars(&self) -> &str {
        "=."
    }

    // VSCode is our reference implementation, so we allow ourselves to work around issues by
    // special casing certain versions
    pub fn visual_studio_code_version(&self) -> Option<&Version> {
        self.client_info
            .as_ref()
            .filter(|it| it.name.starts_with("Visual Studio Code"))
            .and_then(|it| it.version.as_ref())
    }

    pub fn client_is_neovim(&self) -> bool {
        self.client_info.as_ref().map(|it| it.name == "Neovim").unwrap_or_default()
    }
}

// Deserialization definitions

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(untagged)]
enum ManifestOrProjectJson {
    Manifest(Utf8PathBuf),
    ProjectJson(ProjectJsonData),
    DiscoveredProjectJson {
        data: ProjectJsonData,
        #[serde(serialize_with = "serialize_abs_pathbuf")]
        #[serde(deserialize_with = "deserialize_abs_pathbuf")]
        buildfile: AbsPathBuf,
    },
}

fn deserialize_abs_pathbuf<'de, D>(de: D) -> std::result::Result<AbsPathBuf, D::Error>
where
    D: serde::de::Deserializer<'de>,
{
    let path = String::deserialize(de)?;

    AbsPathBuf::try_from(path.as_ref())
        .map_err(|err| serde::de::Error::custom(format!("invalid path name: {err:?}")))
}

fn serialize_abs_pathbuf<S>(path: &AbsPathBuf, se: S) -> Result<S::Ok, S::Error>
where
    S: serde::Serializer,
{
    let path: &Utf8Path = path.as_ref();
    se.serialize_str(path.as_str())
}

#[derive(Serialize, Deserialize, Debug, Clone)]
#[serde(untagged)]
#[serde(rename_all = "snake_case")]
pub enum AutoImportExclusion {
    Path(String),
    Verbose { path: String, r#type: AutoImportExclusionType },
}

#[derive(Serialize, Deserialize, Debug, Clone)]
#[serde(rename_all = "snake_case")]
pub enum AutoImportExclusionType {
    Always,
    Methods,
}
